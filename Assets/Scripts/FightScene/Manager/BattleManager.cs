using System.Collections;
using System.Linq;
using UnityEngine;
using UnityEngine.InputSystem;

public class BattleManager : MonoBehaviour
{
    public static BattleManager Instance { get; private set; }

    [System.Serializable]
    public enum ETeam
    {
        None,
        Player,
        Enemy
    }

    [System.Serializable]
    public enum UnitClass
    {
        Warrior,
        Mage,
        Shield,
        Priest,
        Ranger,
        Enemy
    }

    [System.Serializable]
    public class TeamSlotInfo
    {
        [Header("Prefab 設定")]
        public GameObject PrefabToSpawn;

        [Header("場上關聯")]
        public string UnitName;
        public GameObject Actor;
        public Transform SlotTransform;
        public UnitClass ClassType = UnitClass.Warrior;

        [Header("戰鬥數值")]
        public int MaxHP = 100;
        public int HP = 100;
        public int MaxMP = 100;
        public int MP = 0;
        public int OriginAtk = 10;
        public int Atk = 10;

        [Header("技能")]
        public string[] SkillNames;
        public GameObject[] SkillPrefabs;

        [Header("普通攻擊")]
        public string[] NormalAttackNames;
        public GameObject[] NormalAttackPrefabs;

        [Header("輸入綁定")]
        public int AssignedKeyIndex;
    }

    [Header("我方固定座標（右側）")]
    [SerializeField] private Transform[] playerPositions = new Transform[3];

    [Header("敵方固定座標（左側）")]
    [SerializeField] private Transform[] enemyPositions = new Transform[3];

    [Header("我方三格資料")]
    public TeamSlotInfo[] CTeamInfo = new TeamSlotInfo[3];

    [Header("敵方三格資料")]
    public TeamSlotInfo[] EnemyTeamInfo = new TeamSlotInfo[3];  // ★ 改名避免 enum 衝突

    [Header("輸入（新 Input System）")]
    public InputActionReference actionAttackP1;
    public InputActionReference actionAttackP2;
    public InputActionReference actionAttackP3;
    public InputActionReference actionRotateLeft;
    public InputActionReference actionRotateRight;
    public InputActionReference actionBlockP1;
    public InputActionReference actionBlockP2;
    public InputActionReference actionBlockP3;

    [Header("時序與運動參數")]
    public float actionLockDuration = 0.5f;
    public float dashDuration = 0.05f;
    public float dashStayDuration = 0.15f;
    public float rotateMoveDuration = 0.2f;
    public Vector3 meleeContactOffset = new Vector3(-1f, 0f, 0f);

    [Header("特效 Prefab")]
    public GameObject meleeVfxPrefab;
    public GameObject rangedVfxPrefab;
    public GameObject shieldStrikeVfxPrefab;
    public GameObject missVfxPrefab;
    public GameObject magicUseAuraPrefab;
    public float vfxLifetime = 1.5f;

    [Header("Shield 設定")]
    public float shieldBlockDuration = 2.0f;
    public int shieldDamage = 10;

    [Header("血條 UI")]
    public GameObject healthBarPrefab;
    public Canvas uiCanvas;

    private bool _isActionLocked;
    private bool _isBlockingActive = false;
    private GameObject lastSuccessfulAttacker = null;

    // 用於安全解除 Input 綁定
    private System.Action<InputAction.CallbackContext> attackP1Handler;
    private System.Action<InputAction.CallbackContext> attackP2Handler;
    private System.Action<InputAction.CallbackContext> attackP3Handler;
    private System.Action<InputAction.CallbackContext> blockP1Handler;
    private System.Action<InputAction.CallbackContext> blockP2Handler;
    private System.Action<InputAction.CallbackContext> blockP3Handler;

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;

        // 確保陣列初始化
        if (CTeamInfo == null || CTeamInfo.Length == 0)
            CTeamInfo = new TeamSlotInfo[3];
        if (EnemyTeamInfo == null || EnemyTeamInfo.Length == 0)
            EnemyTeamInfo = new TeamSlotInfo[3];
    }

    private void OnEnable()
    {
        attackP1Handler = ctx => OnAttackKey(0);
        attackP2Handler = ctx => OnAttackKey(1);
        attackP3Handler = ctx => OnAttackKey(2);
        blockP1Handler = ctx => OnBlockKey(0);
        blockP2Handler = ctx => OnBlockKey(1);
        blockP3Handler = ctx => OnBlockKey(2);

        if (actionAttackP1 != null) { actionAttackP1.action.started += attackP1Handler; actionAttackP1.action.Enable(); }
        if (actionAttackP2 != null) { actionAttackP2.action.started += attackP2Handler; actionAttackP2.action.Enable(); }
        if (actionAttackP3 != null) { actionAttackP3.action.started += attackP3Handler; actionAttackP3.action.Enable(); }
        if (actionBlockP1 != null) { actionBlockP1.action.started += blockP1Handler; actionBlockP1.action.Enable(); }
        if (actionBlockP2 != null) { actionBlockP2.action.started += blockP2Handler; actionBlockP2.action.Enable(); }
        if (actionBlockP3 != null) { actionBlockP3.action.started += blockP3Handler; actionBlockP3.action.Enable(); }
    }

    private void OnDisable()
    {
        if (actionAttackP1 != null) actionAttackP1.action.started -= attackP1Handler;
        if (actionAttackP2 != null) actionAttackP2.action.started -= attackP2Handler;
        if (actionAttackP3 != null) actionAttackP3.action.started -= attackP3Handler;
        if (actionBlockP1 != null) actionBlockP1.action.started -= blockP1Handler;
        if (actionBlockP2 != null) actionBlockP2.action.started -= blockP2Handler;
        if (actionBlockP3 != null) actionBlockP3.action.started -= blockP3Handler;
    }

    // --------------------------------------------------
    // 隊伍資料載入
    // --------------------------------------------------
    public void LoadTeamData(BattleTeamManager teamMgr)
    {
        if (teamMgr == null) return;

        CTeamInfo = teamMgr.CTeamInfo.ToArray();        // 深拷貝避免共用參考
        EnemyTeamInfo = teamMgr.EnemyTeamInfo.ToArray();

        Debug.Log("載入隊伍成功，玩家角色：" +
            string.Join(", ", CTeamInfo.Where(x => x != null).Select(x => x.UnitName)));
    }

    // --------------------------------------------------
    // 攻擊邏輯
    // --------------------------------------------------
    private void OnAttackKey(int index)
    {
        if (_isActionLocked) return;
        if (index < 0 || index >= CTeamInfo.Length) return;
        if (CTeamInfo[index] == null) return;

        bool perfect = BeatJudge.Instance.IsOnBeat();
        if (!perfect)
        {
            Debug.Log("Miss！未在節拍上，不觸發攻擊。");
            return;
        }

        var attacker = CTeamInfo[index];
        var target = FindEnemyByClass(attacker.ClassType);
        if (target == null) return;

        // 換角色重置 combo
        //if (lastSuccessfulAttacker != null && lastSuccessfulAttacker != attacker.Actor)
        //    ResetAllComboStates();

        lastSuccessfulAttacker = attacker.Actor;
        StartCoroutine(LockAction(actionLockDuration));

        int beatInCycle = BeatManager.Instance.predictedNextBeat;

        if (attacker.ClassType == UnitClass.Warrior)
            StartCoroutine(HandleWarriorAttack(attacker, target, beatInCycle, perfect));
        else if (attacker.ClassType == UnitClass.Mage)
            StartCoroutine(HandleMageAttack(attacker, target, beatInCycle, perfect));
        else
            StartCoroutine(AttackSequence(attacker, target, target.SlotTransform.position, perfect));

    }

    private IEnumerator HandleWarriorAttack(TeamSlotInfo attacker, TeamSlotInfo target, int beatInCycle, bool perfect)
    {
        var actor = attacker.Actor.transform;
        Vector3 origin = actor.position;
        Vector3 targetPoint = target.SlotTransform.position + meleeContactOffset;

        var charData = attacker.Actor.GetComponent<CharacterData>();
        if (charData == null)
        {
            yield return AttackSequence(attacker, target, targetPoint, perfect);
            yield break;
        }

        SkillInfo chosenSkill = null;
        GameObject attackPrefab = null;

        // ★ 新邏輯：只要是第四拍就觸發重攻擊
        if (beatInCycle == BeatManager.Instance.beatsPerMeasure)
        {
            chosenSkill = charData.HeavyAttack;
            attackPrefab = chosenSkill?.SkillPrefab;
            Debug.Log($"[戰士重攻擊] 第 {beatInCycle} 拍觸發重攻擊！");
        }
        else
        {
            // 依拍數循環普通攻擊（例如第1~3拍用一般攻擊循環）
            int phase = ((beatInCycle - 1) % 3);
            chosenSkill = charData.NormalAttacks[phase];
            attackPrefab = chosenSkill?.SkillPrefab;
            Debug.Log($"[戰士普攻] 第 {beatInCycle} 拍，使用第 {phase + 1} 階普攻。");
        }

        if (attackPrefab == null && meleeVfxPrefab != null)
            attackPrefab = meleeVfxPrefab;

        // 前進揮擊
        yield return Dash(actor, origin, targetPoint, dashDuration);

        if (attackPrefab != null)
        {
            var skillObj = Instantiate(attackPrefab, targetPoint, Quaternion.identity);
            var sword = skillObj.GetComponent<SwordHitSkill>();
            if (sword != null)
            {
                sword.attacker = attacker;
                sword.target = target;
                sword.isPerfect = perfect;
                sword.isHeavyAttack = (beatInCycle == BeatManager.Instance.beatsPerMeasure);
            }
        }

        yield return new WaitForSeconds(dashStayDuration);
        yield return Dash(actor, targetPoint, origin, dashDuration);
    }

    private IEnumerator HandleMageAttack(TeamSlotInfo attacker, TeamSlotInfo target, int beatInCycle, bool perfect)
    {
        var actor = attacker.Actor.transform;
        var charData = attacker.Actor.GetComponent<CharacterData>();
        if (charData == null) yield break;

        // 取得目前充電層數
        int chargeStacks = BattleEffectManager.Instance.GetChargeStacks(attacker);

        // === 第四拍：釋放重攻擊 ===
        if (beatInCycle == BeatManager.Instance.beatsPerMeasure)
        {
            if (chargeStacks <= 0)
            {
                Debug.Log("[法師重攻擊] 無充能層，攻擊無效。");
                yield break;
            }

            Debug.Log($"[法師重攻擊] 施放重攻擊，消耗 {chargeStacks} 層充電。");
            BattleEffectManager.Instance.ResetChargeStacks(attacker); // 清除充電層與特效


            // 生成重攻擊特效
            if (charData.HeavyAttack != null && charData.HeavyAttack.SkillPrefab != null)
            {
                var heavy = Instantiate(charData.HeavyAttack.SkillPrefab, target.SlotTransform.position, Quaternion.identity);
                var skill = heavy.GetComponent<FireBallSkill>();
                if (skill != null)
                {
                    skill.attacker = attacker;
                    skill.target = target;
                    skill.isPerfect = perfect;
                    skill.isHeavyAttack = true;
                    skill.damage = chargeStacks * 30;
                }
            }

            // 計算傷害 = chargeStacks * 30
            int damage = chargeStacks * 30;
            target.HP -= damage;
            if (target.HP < 0) target.HP = 0;

            Debug.Log($"[法師重攻擊] {attacker.UnitName} 對 {target.UnitName} 造成 {damage} 傷害（充電層：{chargeStacks}）");

            // 重置充電層
            BattleEffectManager.Instance.ResetChargeStacks(attacker);

            // 更新血條
            var hb = target.Actor?.GetComponentInChildren<HealthBarUI>();
            if (hb != null) hb.ForceUpdate();

            //if (target.HP <= 0)
            //    BattleEffectManager.Instance.HandleUnitDefeated(target);
        }
        else
        {
            // === 普通攻擊：0 傷害，獲得一層充能 ===
            Debug.Log($"[法師普攻] 第 {beatInCycle} 拍充能 +1 層。");

            // 生成充能亮光特效（無論是否已有層）
            if (charData.NormalAttacks != null && charData.NormalAttacks.Count > 0)
            {
                var chargeEffect = charData.NormalAttacks[0].SkillPrefab;
                if (chargeEffect != null)
                {
                    Vector3 spawnPos = actor.position;
                    Instantiate(chargeEffect, spawnPos, Quaternion.identity);
                    Debug.Log($"[法師普攻特效] {attacker.UnitName} 生成亮光特效於 {spawnPos}");
                }
            }

            // 通知 BattleEffectManager 處理充能層與特效
            BattleEffectManager.Instance.AddChargeStack(attacker);

        }

        yield return null;
    }


    // --------------------------------------------------
    // 格檔
    // --------------------------------------------------
    private void OnBlockKey(int index)
    {
        if (_isActionLocked) return;
        if (index < 0 || index >= CTeamInfo.Length) return;
        var slot = CTeamInfo[index];
        if (slot == null || slot.Actor == null) return;

        bool perfect = BeatJudge.Instance.IsOnBeat();
        if (!perfect)
        {
            Debug.Log("Miss！格檔未在節拍上。");
            return;
        }

        var charData = slot.Actor.GetComponent<CharacterData>();
        if (charData == null) return;

        BattleEffectManager.Instance.ActivateBlock(index, BeatManager.Instance.beatTravelTime, charData, slot.Actor);
    }

    private void ResetAllComboStates()
    {
        foreach (var slot in CTeamInfo)
        {
            if (slot?.Actor == null) continue;
            var combo = slot.Actor.GetComponent<CharacterComboState>();
            if (combo != null)
            {
                combo.comboCount = 0;
                combo.currentPhase = 1;
            }
        }
        lastSuccessfulAttacker = null;
    }

    // --------------------------------------------------
    // 旋轉邏輯
    // --------------------------------------------------
    private void RotateTeamClockwise()
    {
        var temp = CTeamInfo[2];
        CTeamInfo[2] = CTeamInfo[1];
        CTeamInfo[1] = CTeamInfo[0];
        CTeamInfo[0] = temp;
        UpdatePositions();
    }

    private void RotateTeamCounterClockwise()
    {
        var temp = CTeamInfo[0];
        CTeamInfo[0] = CTeamInfo[1];
        CTeamInfo[1] = CTeamInfo[2];
        CTeamInfo[2] = temp;
        UpdatePositions();
    }

    private void UpdatePositions()
    {
        for (int i = 0; i < CTeamInfo.Length; i++)
        {
            if (CTeamInfo[i]?.Actor == null) continue;
            StartCoroutine(MoveToPosition(CTeamInfo[i].Actor.transform, playerPositions[i].position, rotateMoveDuration));
            CTeamInfo[i].SlotTransform = playerPositions[i];
        }
    }

    private IEnumerator MoveToPosition(Transform actor, Vector3 targetPos, float duration)
    {
        if (actor == null) yield break;
        Vector3 start = actor.position;
        float t = 0f;
        while (t < 1f)
        {
            if (actor == null) yield break;
            t += Time.deltaTime / duration;
            actor.position = Vector3.Lerp(start, targetPos, t);
            yield return null;
        }
    }

    private IEnumerator LockAction(float duration)
    {
        _isActionLocked = true;
        yield return new WaitForSeconds(duration);
        _isActionLocked = false;
    }

    // --------------------------------------------------
    // 攻擊序列與敵人搜尋
    // --------------------------------------------------
    private IEnumerator AttackSequence(TeamSlotInfo attacker, TeamSlotInfo target, Vector3 targetPoint, bool perfect)
    {
        if (attacker == null || target == null) yield break;

        var actor = attacker.Actor.transform;
        Vector3 origin = actor.position;

        switch (attacker.ClassType)
        {
            case UnitClass.Mage:
                if (magicUseAuraPrefab != null)
                {
                    var aura = Instantiate(magicUseAuraPrefab, actor.position, Quaternion.identity);
                    if (vfxLifetime > 0f) Destroy(aura, vfxLifetime);
                }
                foreach (var enemy in EnemyTeamInfo)
                {
                    if (enemy?.Actor == null) continue;
                    var fireball = Instantiate(rangedVfxPrefab, actor.position, Quaternion.identity)
                        .GetComponent<FireBallSkill>();
                    if (fireball != null)
                    {
                        fireball.attacker = attacker;
                        fireball.target = enemy;
                        fireball.isPerfect = perfect;
                    }
                }
                break;

            default:
                Vector3 contact = targetPoint + meleeContactOffset;
                yield return Dash(actor, origin, contact, dashDuration);

                var vfx = Instantiate(meleeVfxPrefab, targetPoint, Quaternion.identity);
                var sword = vfx.GetComponent<SwordHitSkill>();
                if (sword != null)
                {
                    sword.attacker = attacker;
                    sword.target = target;
                    sword.isPerfect = perfect;
                }

                yield return new WaitForSeconds(dashStayDuration);
                yield return Dash(actor, contact, origin, dashDuration);
                break;
        }
    }

    private TeamSlotInfo FindEnemyByClass(UnitClass cls)
    {
        if (cls == UnitClass.Warrior)
            return EnemyTeamInfo.FirstOrDefault(e => e != null && e.Actor != null);

        if (cls == UnitClass.Mage)
            return EnemyTeamInfo.FirstOrDefault(e => e != null && e.Actor != null);

        if (cls == UnitClass.Ranger)
            return FindLastValidEnemy();

        return FindNextValidEnemy(0);
    }

    private TeamSlotInfo FindLastValidEnemy()
    {
        for (int i = EnemyTeamInfo.Length - 1; i >= 0; i--)
            if (EnemyTeamInfo[i]?.Actor != null)
                return EnemyTeamInfo[i];
        return null;
    }

    private TeamSlotInfo FindNextValidEnemy(int startIndex)
    {
        for (int i = startIndex; i < EnemyTeamInfo.Length; i++)
            if (EnemyTeamInfo[i]?.Actor != null)
                return EnemyTeamInfo[i];
        return null;
    }

    private IEnumerator Dash(Transform actor, Vector3 from, Vector3 to, float duration)
    {
        if (actor == null) yield break;
        float t = 0f;
        while (t < 1f)
        {
            if (actor == null) yield break;
            t += Time.deltaTime / duration;
            actor.position = Vector3.Lerp(from, to, t);
            yield return null;
        }
    }

    // --------------------------------------------------
    // 敵人死亡與前推
    // --------------------------------------------------
    public void OnEnemyDeath(int deadIndex)
    {
        if (deadIndex < 0 || deadIndex >= EnemyTeamInfo.Length)
            return;

        var deadSlot = EnemyTeamInfo[deadIndex];
        if (deadSlot?.Actor != null)
            Destroy(deadSlot.Actor);
        if (deadSlot != null)
            deadSlot.Actor = null;

        //ShiftEnemiesForward();
    }

    //private void ShiftEnemiesForward()
    //{
    //    StartCoroutine(ShiftEnemiesForwardRoutine());
    //}

    //private IEnumerator ShiftEnemiesForwardRoutine()
    //{
    //    bool moved = false;

    //    for (int i = 1; i < EnemyTeamInfo.Length; i++)
    //    {
    //        if ((EnemyTeamInfo[i - 1] == null || EnemyTeamInfo[i - 1].Actor == null) &&
    //            (EnemyTeamInfo[i]?.Actor != null))
    //        {
    //            var enemy = EnemyTeamInfo[i].Actor;
    //            if (enemy == null) continue;

    //            Vector3 targetPos = enemyPositions[i - 1].position;

    //            var enemyBase = enemy.GetComponent<EnemyBase>();
    //            if (enemyBase != null) enemyBase.SetForceMove(true);

    //            float t = 0f;
    //            Vector3 start = enemy.transform.position;
    //            float moveTime = 0.25f;
    //            while (t < 1f)
    //            {
    //                if (enemy == null) yield break;
    //                t += Time.deltaTime / moveTime;
    //                enemy.transform.position = Vector3.Lerp(start, targetPos, t);
    //                yield return null;
    //            }

    //            EnemyTeamInfo[i - 1] = EnemyTeamInfo[i];
    //            EnemyTeamInfo[i - 1].SlotTransform = enemyPositions[i - 1];
    //            EnemyTeamInfo[i] = null;

    //            if (enemyBase != null)
    //            {
    //                enemyBase.SetForceMove(false);
    //                enemyBase.SendMessage("RefreshBasePosition", SendMessageOptions.DontRequireReceiver);
    //            }

    //            moved = true;
    //            yield return new WaitForSeconds(0.05f);
    //        }
    //    }

    //    if (moved)
    //        Debug.Log("敵人整隊前推完成");
    //}
}
